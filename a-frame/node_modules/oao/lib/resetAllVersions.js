'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _timm = require('timm');

var _storyboard = require('storyboard');

var _inquirer = require('inquirer');

var _inquirer2 = _interopRequireDefault(_inquirer);

var _semver = require('semver');

var _semver2 = _interopRequireDefault(_semver);

var _readSpecs = require('./utils/readSpecs');

var _writeSpecs = require('./utils/writeSpecs');

var _writeSpecs2 = _interopRequireDefault(_writeSpecs);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

var run = function () {
  var _ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee(version, _ref2) {
    var src = _ref2.src,
        ignoreSrc = _ref2.ignoreSrc,
        _ref2$confirm = _ref2.confirm,
        confirm = _ref2$confirm === undefined ? true : _ref2$confirm;

    var allSpecs, pkgNames, _ref3, goAhead, i, pkgName, _allSpecs$pkgName, specPath, prevSpecs, nextSpecs;

    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (_semver2.default.valid(version)) {
              _context.next = 3;
              break;
            }

            _storyboard.mainStory.error('Version ' + version + ' is not valid');
            throw new Error('INVALID_VERSION');

          case 3:
            _context.next = 5;
            return (0, _readSpecs.readAllSpecs)(src, ignoreSrc);

          case 5:
            allSpecs = _context.sent;
            pkgNames = Object.keys(allSpecs);

            // Ask for confirmation

            if (!confirm) {
              _context.next = 13;
              break;
            }

            _context.next = 10;
            return _inquirer2.default.prompt([{
              name: 'goAhead',
              type: 'confirm',
              message: 'Are you sure you want to reset the version number of all packages, ' + ('including the monorepo root, to ' + _storyboard.chalk.cyan.yellow(version) + ' ') + ('(' + _storyboard.chalk.cyan.bold(pkgNames.length) + ' package/s, including monorepo)?'),
              default: false
            }]);

          case 10:
            _ref3 = _context.sent;
            goAhead = _ref3.goAhead;

            if (!goAhead) process.exit(0);

          case 13:

            for (i = 0; i < pkgNames.length; i++) {
              pkgName = pkgNames[i];
              _allSpecs$pkgName = allSpecs[pkgName], specPath = _allSpecs$pkgName.specPath, prevSpecs = _allSpecs$pkgName.specs;
              nextSpecs = (0, _timm.set)(prevSpecs, 'version', version);

              (0, _writeSpecs2.default)(specPath, nextSpecs);
            }

          case 14:
          case 'end':
            return _context.stop();
        }
      }
    }, _callee, undefined);
  }));

  return function run(_x, _x2) {
    return _ref.apply(this, arguments);
  };
}();

exports.default = run;