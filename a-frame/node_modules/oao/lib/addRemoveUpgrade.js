'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _timm = require('timm');

var _storyboard = require('storyboard');

var _kebabCase = require('kebab-case');

var _kebabCase2 = _interopRequireDefault(_kebabCase);

var _readSpecs = require('./utils/readSpecs');

var _removeInternalLinks2 = require('./utils/removeInternalLinks');

var _removeInternalLinks3 = _interopRequireDefault(_removeInternalLinks2);

var _writeSpecs = require('./utils/writeSpecs');

var _writeSpecs2 = _interopRequireDefault(_writeSpecs);

var _shell = require('./utils/shell');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

var PASS_THROUGH_OPTS = ['dev', 'peer', 'optional', 'exact', 'tilde', 'ignoreEngines'];
var DEP_TYPES = ['dependencies', 'devDependencies', 'peerDependencies', 'optionalDependencies'];

var run = function () {
  var _ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee(pkgName0, op, deps, opts) {
    var src, ignoreSrc, linkPattern, pkgName, allSpecs, pkgNames, _allSpecs$pkgName, pkgPath, specPath, prevSpecs, externalDeps, externalOperation, _removeInternalLinks, nextSpecs, removedPackagesByType, succeeded, cmd, _readOneSpec, updatedSpecs, finalSpecs, internalDeps, internalOperation, _readOneSpec2, specs, _nextSpecs;

    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            src = opts.src, ignoreSrc = opts.ignoreSrc, linkPattern = opts.link;
            pkgName = pkgName0 === '.' || pkgName0 === 'ROOT' ? _readSpecs.ROOT_PACKAGE : pkgName0;
            _context.next = 4;
            return (0, _readSpecs.readAllSpecs)(src, ignoreSrc);

          case 4:
            allSpecs = _context.sent;

            if (!allSpecs[pkgName]) {
              _storyboard.mainStory.error('No such package: ' + pkgName);
              process.exit(1);
            }

            pkgNames = Object.keys(allSpecs);
            _allSpecs$pkgName = allSpecs[pkgName], pkgPath = _allSpecs$pkgName.pkgPath, specPath = _allSpecs$pkgName.specPath, prevSpecs = _allSpecs$pkgName.specs;

            // Add/remove/upgrade EXTERNAL dependencies:
            // 1. Remove internal links from package.json
            // 2. Run `yarn add/remove/upgrade` as needed (if it fails, revert to original specs and abort)
            // 3. Add the original internal links back to package.json

            externalDeps = deps.filter(function (dep) {
              return !isLinked(pkgNames, linkPattern, dep);
            });
            externalOperation = externalDeps.length || op === 'upgrade' && !deps.length;

            if (!externalOperation) {
              _context.next = 33;
              break;
            }

            _removeInternalLinks = (0, _removeInternalLinks3.default)(prevSpecs, pkgNames, linkPattern), nextSpecs = _removeInternalLinks.nextSpecs, removedPackagesByType = _removeInternalLinks.removedPackagesByType;
            succeeded = false;
            _context.prev = 13;

            if (nextSpecs !== prevSpecs) (0, _writeSpecs2.default)(specPath, nextSpecs);
            _storyboard.mainStory.info('Executing \'yarn ' + op + '\'...');
            cmd = 'yarn ' + op;

            if (externalDeps.length) cmd += ' ' + externalDeps.join(' ');
            PASS_THROUGH_OPTS.forEach(function (key) {
              if (opts[key]) cmd += ' --' + (0, _kebabCase2.default)(key);
            });
            _context.next = 21;
            return (0, _shell.exec)(cmd, { cwd: pkgPath });

          case 21:
            succeeded = true;
            _context.next = 26;
            break;

          case 24:
            _context.prev = 24;
            _context.t0 = _context['catch'](13);

          case 26:
            if (succeeded) {
              _context.next = 29;
              break;
            }

            if (prevSpecs != null) (0, _writeSpecs2.default)(specPath, prevSpecs);
            return _context.abrupt('return');

          case 29:
            // Read the updated package.json, and add the internal deps
            _readOneSpec = (0, _readSpecs.readOneSpec)(pkgPath), updatedSpecs = _readOneSpec.specs;
            finalSpecs = updatedSpecs;

            Object.keys(removedPackagesByType).forEach(function (type) {
              var removedPackages = removedPackagesByType[type];
              var nextDeps = (0, _timm.merge)(updatedSpecs[type] || {}, removedPackages);
              finalSpecs = (0, _timm.set)(finalSpecs, type, nextDeps);
            });
            (0, _writeSpecs2.default)(specPath, finalSpecs);

          case 33:

            // Add/remove/upgrade INTERNAL dependencies:
            internalDeps = deps.filter(function (dep) {
              return isLinked(pkgNames, linkPattern, dep);
            });
            internalOperation = internalDeps.length || op === 'upgrade' && !deps.length;

            if (!internalOperation) {
              _context.next = 54;
              break;
            }

            _storyboard.mainStory.info('Processing \'' + op + '\' on internal dependencies...');
            _readOneSpec2 = (0, _readSpecs.readOneSpec)(pkgPath), specs = _readOneSpec2.specs;
            _nextSpecs = void 0;
            _context.t1 = op;
            _context.next = _context.t1 === 'add' ? 42 : _context.t1 === 'remove' ? 46 : _context.t1 === 'upgrade' ? 50 : 52;
            break;

          case 42:
            _context.next = 44;
            return addInternal(specs, internalDeps, pkgPath, allSpecs, opts);

          case 44:
            _nextSpecs = _context.sent;
            return _context.abrupt('break', 53);

          case 46:
            _context.next = 48;
            return removeInternal(specs, internalDeps, pkgPath);

          case 48:
            _nextSpecs = _context.sent;
            return _context.abrupt('break', 53);

          case 50:
            _nextSpecs = upgradeInternal(specs, internalDeps, allSpecs, linkPattern);
            return _context.abrupt('break', 53);

          case 52:
            throw new Error('INVALID_ADD_REMOVE_UPGRADE_COMMAND');

          case 53:
            if (_nextSpecs !== prevSpecs) (0, _writeSpecs2.default)(specPath, _nextSpecs);

          case 54:
          case 'end':
            return _context.stop();
        }
      }
    }, _callee, undefined, [[13, 24]]);
  }));

  return function run(_x, _x2, _x3, _x4) {
    return _ref.apply(this, arguments);
  };
}();

var addInternal = function () {
  var _ref2 = _asyncToGenerator(regeneratorRuntime.mark(function _callee2(prevSpecs, deps, pkgPath, allSpecs, opts) {
    var nextSpecs, i, _deps$i$split, _deps$i$split2, depName, depVersion0, depType, depVersion;

    return regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            nextSpecs = prevSpecs;
            i = 0;

          case 2:
            if (!(i < deps.length)) {
              _context2.next = 20;
              break;
            }

            _deps$i$split = deps[i].split('@'), _deps$i$split2 = _slicedToArray(_deps$i$split, 2), depName = _deps$i$split2[0], depVersion0 = _deps$i$split2[1];
            _context2.prev = 4;

            _storyboard.mainStory.info('Linking ' + _storyboard.chalk.cyan.bold(depName) + '...');
            _context2.next = 8;
            return (0, _shell.exec)('yarn link ' + depName, {
              cwd: pkgPath,
              logLevel: 'trace',
              errorLogLevel: 'trace'
            });

          case 8:
            _context2.next = 12;
            break;

          case 10:
            _context2.prev = 10;
            _context2.t0 = _context2['catch'](4);

          case 12:
            depType = void 0;

            if (opts.dev) depType = 'devDependencies';else if (opts.peer) depType = 'peerDependencies';else if (opts.optional) depType = 'optionalDependencies';else depType = 'dependencies';
            depVersion = depVersion0;

            if (!depVersion) {
              depVersion = allSpecs[depName] ? allSpecs[depName].specs.version : '*';
              if (depVersion !== '*') {
                if (opts.tilde) depVersion = '~' + depVersion;else if (!opts.exact) depVersion = '^' + depVersion;
              }
            }
            nextSpecs = (0, _timm.setIn)(nextSpecs, [depType, depName], depVersion);

          case 17:
            i++;
            _context2.next = 2;
            break;

          case 20:
            return _context2.abrupt('return', nextSpecs);

          case 21:
          case 'end':
            return _context2.stop();
        }
      }
    }, _callee2, undefined, [[4, 10]]);
  }));

  return function addInternal(_x5, _x6, _x7, _x8, _x9) {
    return _ref2.apply(this, arguments);
  };
}();

var removeInternal = function () {
  var _ref3 = _asyncToGenerator(regeneratorRuntime.mark(function _callee3(prevSpecs, deps, pkgPath) {
    var nextSpecs, i, _deps$i$split3, _deps$i$split4, depName, k, type;

    return regeneratorRuntime.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            nextSpecs = prevSpecs;
            i = 0;

          case 2:
            if (!(i < deps.length)) {
              _context3.next = 24;
              break;
            }

            _deps$i$split3 = deps[i].split('@'), _deps$i$split4 = _slicedToArray(_deps$i$split3, 1), depName = _deps$i$split4[0];
            _context3.prev = 4;

            _storyboard.mainStory.info('Unlinking ' + _storyboard.chalk.cyan.bold(depName) + '...');
            _context3.next = 8;
            return (0, _shell.exec)('yarn unlink ' + depName, {
              cwd: pkgPath,
              logLevel: 'trace',
              errorLogLevel: 'trace'
            });

          case 8:
            _context3.next = 12;
            break;

          case 10:
            _context3.prev = 10;
            _context3.t0 = _context3['catch'](4);

          case 12:
            k = 0;

          case 13:
            if (!(k < DEP_TYPES.length)) {
              _context3.next = 21;
              break;
            }

            type = DEP_TYPES[k];

            if (nextSpecs[type]) {
              _context3.next = 17;
              break;
            }

            return _context3.abrupt('continue', 18);

          case 17:
            nextSpecs = (0, _timm.setIn)(nextSpecs, [type, depName], undefined);

          case 18:
            k++;
            _context3.next = 13;
            break;

          case 21:
            i++;
            _context3.next = 2;
            break;

          case 24:
            return _context3.abrupt('return', nextSpecs);

          case 25:
          case 'end':
            return _context3.stop();
        }
      }
    }, _callee3, undefined, [[4, 10]]);
  }));

  return function removeInternal(_x10, _x11, _x12) {
    return _ref3.apply(this, arguments);
  };
}();

var upgradeInternal = function upgradeInternal(prevSpecs, deps, allSpecs, linkPattern) {
  var pkgNames = Object.keys(allSpecs);
  var nextSpecs = prevSpecs;
  var targetVersions = {};
  deps.forEach(function (dep) {
    var _dep$split = dep.split('@'),
        _dep$split2 = _slicedToArray(_dep$split, 2),
        name = _dep$split2[0],
        version = _dep$split2[1];

    targetVersions[name] = version;
  });
  DEP_TYPES.forEach(function (type) {
    Object.keys(nextSpecs[type] || {}).forEach(function (depName) {
      if (!isLinked(pkgNames, linkPattern, depName)) return;
      var depVersion = targetVersions[depName];
      if (!depVersion && allSpecs[depName]) {
        depVersion = '^' + allSpecs[depName].specs.version;
      }
      nextSpecs = (0, _timm.setIn)(nextSpecs, [type, depName], depVersion);
    });
  });
  return nextSpecs;
};

var isLinked = function isLinked(pkgNames, linkPattern, dep) {
  var _dep$split3 = dep.split('@'),
      _dep$split4 = _slicedToArray(_dep$split3, 1),
      pkgName = _dep$split4[0];

  if (pkgNames.indexOf(pkgName) >= 0) return true;
  if (linkPattern && new RegExp(linkPattern).test(pkgName)) return true;
  return false;
};

exports.default = run;