'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _timm = require('timm');

var _semver = require('semver');

var _semver2 = _interopRequireDefault(_semver);

var _storyboard = require('storyboard');

var _readSpecs = require('./utils/readSpecs');

var _writeSpecs = require('./utils/writeSpecs');

var _writeSpecs2 = _interopRequireDefault(_writeSpecs);

var _shell = require('./utils/shell');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

var run = function () {
  var _ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee(_ref2) {
    var src = _ref2.src,
        ignoreSrc = _ref2.ignoreSrc,
        copyAttrsStr = _ref2.copyAttrs;

    var allSpecs, pkgNames, rootSpecs, masterVersion, i, pkgName, specs, version, _i, _pkgName, _allSpecs$_pkgName, pkgPath, srcFile, dstFile, commonSpecs, copyAttrs, _i2, _pkgName2, _allSpecs$_pkgName2, specPath, prevSpecs, nextSpecs;

    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return (0, _readSpecs.readAllSpecs)(src, ignoreSrc);

          case 2:
            allSpecs = _context.sent;
            pkgNames = Object.keys(allSpecs);
            rootSpecs = allSpecs[_readSpecs.ROOT_PACKAGE].specs;

            // Check version numbers!

            masterVersion = rootSpecs.version;
            i = 0;

          case 7:
            if (!(i < pkgNames.length)) {
              _context.next = 24;
              break;
            }

            pkgName = pkgNames[i];

            if (!(pkgName === _readSpecs.ROOT_PACKAGE)) {
              _context.next = 11;
              break;
            }

            return _context.abrupt('continue', 21);

          case 11:
            specs = allSpecs[pkgName].specs;
            version = specs.version;

            if (!specs.private) {
              _context.next = 15;
              break;
            }

            return _context.abrupt('continue', 21);

          case 15:
            if (_semver2.default.valid(version)) {
              _context.next = 18;
              break;
            }

            _storyboard.mainStory.error('Invalid version for ' + _storyboard.chalk.bold(pkgName) + ': ' + _storyboard.chalk.bold(version));
            throw new Error('INVALID_VERSION');

          case 18:
            if (!_semver2.default.gt(version, masterVersion)) {
              _context.next = 21;
              break;
            }

            _storyboard.mainStory.error('Version for ' + pkgName + ' (' + _storyboard.chalk.bold(version) + ') > master version (' + _storyboard.chalk.bold(masterVersion) + ')');
            throw new Error('INVALID_VERSION');

          case 21:
            i++;
            _context.next = 7;
            break;

          case 24:
            _i = 0;

          case 25:
            if (!(_i < pkgNames.length)) {
              _context.next = 38;
              break;
            }

            _pkgName = pkgNames[_i];

            if (!(_pkgName === _readSpecs.ROOT_PACKAGE)) {
              _context.next = 29;
              break;
            }

            return _context.abrupt('continue', 35);

          case 29:
            _allSpecs$_pkgName = allSpecs[_pkgName], pkgPath = _allSpecs$_pkgName.pkgPath, specs = _allSpecs$_pkgName.specs;

            if (!specs.private) {
              _context.next = 32;
              break;
            }

            return _context.abrupt('continue', 35);

          case 32:
            srcFile = _pkgName === rootSpecs.name ? 'README.md' : 'README-LINK.md';
            dstFile = _path2.default.join(pkgPath, 'README.md');

            (0, _shell.cp)(srcFile, dstFile);

          case 35:
            _i++;
            _context.next = 25;
            break;

          case 38:

            // Merge common attributes with submodules
            commonSpecs = {};
            copyAttrs = copyAttrsStr.split(/\s*,\s*/);

            copyAttrs.forEach(function (attr) {
              commonSpecs[attr] = rootSpecs[attr];
            });
            _storyboard.mainStory.info('Updating package attributes', { attach: commonSpecs });
            _i2 = 0;

          case 43:
            if (!(_i2 < pkgNames.length)) {
              _context.next = 55;
              break;
            }

            _pkgName2 = pkgNames[_i2];

            if (!(_pkgName2 === _readSpecs.ROOT_PACKAGE)) {
              _context.next = 47;
              break;
            }

            return _context.abrupt('continue', 52);

          case 47:
            _allSpecs$_pkgName2 = allSpecs[_pkgName2], specPath = _allSpecs$_pkgName2.specPath, prevSpecs = _allSpecs$_pkgName2.specs;

            if (!prevSpecs.private) {
              _context.next = 50;
              break;
            }

            return _context.abrupt('continue', 52);

          case 50:
            nextSpecs = (0, _timm.merge)(prevSpecs, commonSpecs);

            (0, _writeSpecs2.default)(specPath, nextSpecs);

          case 52:
            _i2++;
            _context.next = 43;
            break;

          case 55:

            _storyboard.mainStory.warn('Please make sure you commit all changes before you attempt "oao publish"');

          case 56:
          case 'end':
            return _context.stop();
        }
      }
    }, _callee, undefined);
  }));

  return function run(_x) {
    return _ref.apply(this, arguments);
  };
}();

exports.default = run;