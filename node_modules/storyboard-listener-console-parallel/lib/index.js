'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _timm = require('timm');

var _terminalKit = require('terminal-kit');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var REQUIRED_CORE_VERSION = '^3.0.0-rc.2';

var DEFAULT_CONFIG = {
  moduleNameLength: 20,
  relativeTime: false,
  colors: true
};

// -----------------------------------------
// Listener
// -----------------------------------------

var ParallelConsoleListener = function () {
  function ParallelConsoleListener(config, _ref) {
    var _this = this;

    var hub = _ref.hub,
        recordToLines = _ref.recordToLines,
        chalk = _ref.chalk;

    _classCallCheck(this, ParallelConsoleListener);

    this.termCheckResize = function () {
      var width = _terminalKit.terminal.width,
          height = _terminalKit.terminal.height;

      if (width !== _this.width || height !== _this.height) {
        _this.width = width;
        _this.height = height;
        _this.termRefreshAll();
      }
    };

    this.type = 'PARALLEL_CONSOLE';
    this.config = config;
    this.hub = hub;
    this.hubId = hub.getHubId();
    this.recordToLines = recordToLines;
    this.chalk = chalk;
    this.prevTime = 0;
  }

  _createClass(ParallelConsoleListener, [{
    key: 'configure',
    value: function configure(config) {
      this.config = (0, _timm.merge)(this.config, config);
    }
  }, {
    key: 'getConfig',
    value: function getConfig() {
      return this.config;
    }
  }, {
    key: 'init',
    value: function init() {
      this.initThreads();
      this.timerCheckSize = setInterval(this.termCheckResize, 500);
      this.termInit();
      this.termCheckResize();
    }
  }, {
    key: 'tearDown',
    value: function tearDown() {
      this.resetCursorPos();
      console.log(''); // eslint-disable-line
      if (this.timerCheckSize != null) {
        clearInterval(this.timerCheckSize);
        this.timerCheckSize = null;
      }
    }

    // -----------------------------------------
    // Main processing function
    // -----------------------------------------

  }, {
    key: 'process',
    value: function process(msg) {
      var _this2 = this;

      if (msg.type !== 'RECORDS') return;
      if (msg.hubId !== this.hubId) return; // only log local records
      msg.data.forEach(function (record) {
        return _this2.processRecord(record);
      });
    }
  }, {
    key: 'processRecord',
    value: function processRecord(record) {
      var _this3 = this;

      if (record.fStory && record.action === 'CREATED' && (record.fRoot || record.parents.length && record.parents[0][0] === '*')) {
        this.createThread(record);
        return;
      }
      var threadId = this.getThread(record);
      if (threadId == null) return;
      if (record.action === 'CLOSED' && record.storyId === threadId) return;
      var options = (0, _timm.set)(this.config, 'prevTime', this.prevTime);
      var lines = this.recordToLines(record, options);
      this.prevTime = new Date(record.t);
      lines.forEach(function (_ref2) {
        var text = _ref2.text,
            fLongDelay = _ref2.fLongDelay;

        if (fLongDelay) _this3.addLineToThread(threadId, '          ...');
        _this3.addLineToThread(threadId, text);
      });
    }

    // -----------------------------------------
    // Terminal
    // -----------------------------------------

  }, {
    key: 'initThreads',
    value: function initThreads() {
      this.threads = {};
      this.storyIdToThreadId = {};
    }
  }, {
    key: 'createThread',
    value: function createThread(record) {
      var storyId = record.storyId,
          t = record.t,
          title = record.title;

      var threadId = storyId;
      this.threads[threadId] = { storyId: storyId, t: t, title: title, open: true, lines: [] };
      this.storyIdToThreadId[storyId] = threadId;
      this.termRefreshAll();
    }
  }, {
    key: 'getThread',
    value: function getThread(record) {
      var storyId = record.storyId;

      // Look up the storyId in the cache

      var threadId = this.storyIdToThreadId[storyId];
      if (threadId != null) return threadId;

      // It's not a story, and its story is not in the cache. We have no clue...
      if (!record.fStory) return null;

      // It's a story. Look for its parents; if they're in the cache, add this new
      // story to the same thread
      var parents = record.parents;

      for (var i = 0; i < parents.length; i++) {
        var parentId = parents[i];
        threadId = this.storyIdToThreadId[parentId];
        if (threadId != null) {
          this.storyIdToThreadId[storyId] = threadId;
          return threadId;
        }
      }

      // Bad luck
      return null;
    }
  }, {
    key: 'addLineToThread',
    value: function addLineToThread(threadId, line) {
      // If terminal height is 0 (e.g. Travis), just print the lines out
      if (!_terminalKit.terminal.height) {
        console.log(line); // eslint-disable-line
        return;
      }
      var thread = this.threads[threadId];
      if (!thread) return;
      thread.lines.push(line);
      // TODO: forget...
      this.termRefreshThread(threadId);
    }

    // -----------------------------------------
    // Terminal
    // -----------------------------------------
    // Clear the terminal, in such a way that we don't overwrite previous history

  }, {
    key: 'termInit',
    value: function termInit() {
      /* eslint-disable no-console */
      for (var i = 0; i < _terminalKit.terminal.height; i++) {
        console.log('');
      } /* eslint-enable no-console */
    }
  }, {
    key: 'termRefreshAll',
    value: function termRefreshAll() {
      var threads = this.threads,
          h0 = this.height;

      if (!h0) return;
      this.termClear();
      var threadIds = Object.keys(threads);
      var len = threadIds.length;
      if (!len) return;
      var truncated = false;
      var h = h0 - 1;
      if (len * 2 > h) {
        truncated = true;
        len = Math.floor(h / 2);
      }
      var delta = h / len;
      for (var i = 0; i < len; i++) {
        var threadId = threadIds[i];
        var thread = threads[threadId];
        thread.idx = i + 1;
        thread.y1 = Math.floor(i * delta);
        thread.y2 = Math.floor((i + 1) * delta) - 1;
        thread.shown = true;
        this.termRefreshThread(threadId, i);
      }
      for (var _i = len; _i < threadIds.length; _i++) {
        threads[threadIds[_i]].shown = false;
      }
      if (truncated) {
        var numHidden = threadIds.length - len;
        var hint = this.chalk.bgRed('  ' + numHidden + ' hidden stor' + (numHidden === 1 ? 'y' : 'ies'));
        _terminalKit.terminal.moveTo(1, h0, hint);
      }
      this.resetCursorPos();
    }
  }, {
    key: 'termClear',
    value: function termClear() {
      var height = _terminalKit.terminal.height;

      for (var i = 0; i < height; i++) {
        _terminalKit.terminal.moveTo(1, i + 1).eraseLine();
        (0, _terminalKit.terminal)('');
      }
    }
  }, {
    key: 'termRefreshThread',
    value: function termRefreshThread(threadId) {
      var thread = this.threads[threadId];
      if (!thread || !thread.shown) return;
      var y1 = thread.y1,
          y2 = thread.y2;
      var w = this.width;

      // Write title

      this.termWriteLine(y1, this.chalk.bgWhite.black.bold(' ' + thread.idx + ' ') + ' ' + thread.title, w);

      // Write as many lines as fit
      var len = y2 - y1;
      var lines = thread.lines.slice(-len);
      for (var i = 0; i < lines.length; i++) {
        var line = '  ' + lines[i];
        this.termWriteLine(y1 + i + 1, line, w);
      }

      this.resetCursorPos();
    }
  }, {
    key: 'termWriteLine',
    value: function termWriteLine(y, text, w) {
      _terminalKit.terminal.moveTo(1, y + 1).eraseLine();
      var uncolored = this.chalk.stripColor(text);
      var finalText = uncolored.length > w ? uncolored.slice(0, w - 1) + '\u2026' : text;
      (0, _terminalKit.terminal)(finalText);
    }
  }, {
    key: 'resetCursorPos',
    value: function resetCursorPos() {
      if (!_terminalKit.terminal.height) return;
      _terminalKit.terminal.moveTo(1, this.height);
    }
  }]);

  return ParallelConsoleListener;
}();

// -----------------------------------------
// API
// -----------------------------------------


var create = function create(userConfig, context) {
  return new ParallelConsoleListener((0, _timm.addDefaults)(userConfig, DEFAULT_CONFIG), context);
};
create.requiredCoreVersion = REQUIRED_CORE_VERSION;

exports.default = create;