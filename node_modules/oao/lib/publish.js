'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _semver = require('semver');

var _semver2 = _interopRequireDefault(_semver);

var _inquirer = require('inquirer');

var _inquirer2 = _interopRequireDefault(_inquirer);

var _storyboard = require('storyboard');

var _readSpecs = require('./utils/readSpecs');

var _writeSpecs = require('./utils/writeSpecs');

var _writeSpecs2 = _interopRequireDefault(_writeSpecs);

var _shell = require('./utils/shell');

var _git = require('./utils/git');

var _changelog = require('./utils/changelog');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

var DEBUG_SKIP_CHECKS = false;
var RELEASE_INCREMENTS = ['major', 'minor', 'patch'];
var PRERELEASE_INCREMENTS = ['rc', 'beta', 'alpha'];
var INCREMENTS = [].concat(RELEASE_INCREMENTS, PRERELEASE_INCREMENTS);

var run = function () {
  var _ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee(_ref2) {
    var src = _ref2.src,
        ignoreSrc = _ref2.ignoreSrc,
        master = _ref2.master,
        checkUncommitted = _ref2.checkUncommitted,
        checkUnpulled = _ref2.checkUnpulled,
        confirm = _ref2.confirm,
        gitCommit = _ref2.gitCommit,
        newVersion = _ref2.newVersion,
        npmPublish = _ref2.npmPublish,
        publishTag = _ref2.publishTag,
        incrementVersionBy = _ref2.incrementVersionBy,
        changelog = _ref2.changelog,
        changelogPath = _ref2.changelogPath,
        _date = _ref2._date,
        _masterVersion = _ref2._masterVersion;

    var allSpecs, _ref3, confirmBuild, lastTag, dirty, masterVersion, nextVersion, _ref4, confirmPublish, dirtyPlusRoot, i, pkgName, _allSpecs$pkgName, specPath, specs, _i, _pkgName, _allSpecs$_pkgName, pkgPath, cmd;

    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return (0, _readSpecs.readAllSpecs)(src, ignoreSrc);

          case 2:
            allSpecs = _context.sent;

            if (!confirm) {
              _context.next = 10;
              break;
            }

            _context.next = 6;
            return _inquirer2.default.prompt([{
              name: 'confirmBuild',
              type: 'confirm',
              message: 'Have you built all your packages for production?',
              default: false
            }]);

          case 6:
            _ref3 = _context.sent;
            confirmBuild = _ref3.confirmBuild;

            if (confirmBuild) {
              _context.next = 10;
              break;
            }

            return _context.abrupt('return');

          case 10:
            _context.next = 12;
            return prepublishChecks({ master: master, checkUncommitted: checkUncommitted, checkUnpulled: checkUnpulled });

          case 12:
            _context.next = 14;
            return (0, _git.gitLastTag)();

          case 14:
            lastTag = _context.sent;
            _context.next = 17;
            return findPackagesToUpdate(allSpecs, lastTag);

          case 17:
            dirty = _context.sent;

            if (dirty.length) {
              _context.next = 21;
              break;
            }

            _storyboard.mainStory.info('No sub-packages have been updated');
            return _context.abrupt('return');

          case 21:
            _context.t0 = _masterVersion;

            if (_context.t0) {
              _context.next = 26;
              break;
            }

            _context.next = 25;
            return getMasterVersion(allSpecs, lastTag);

          case 25:
            _context.t0 = _context.sent;

          case 26:
            masterVersion = _context.t0;

            if (!(masterVersion == null)) {
              _context.next = 29;
              break;
            }

            return _context.abrupt('return');

          case 29:
            if (!incrementVersionBy) {
              _context.next = 35;
              break;
            }

            if (!(INCREMENTS.indexOf(incrementVersionBy) < 0)) {
              _context.next = 35;
              break;
            }

            _storyboard.mainStory.error('Value specified for --increment-version-by: ' + _storyboard.chalk.bold(incrementVersionBy) + ' is invalid.');
            _storyboard.mainStory.error('It should be one of (' + INCREMENTS.join(', ') + '), or not specified.');

            if (DEBUG_SKIP_CHECKS) {
              _context.next = 35;
              break;
            }

            throw new Error('INVALID_INCREMENT_BY_VALUE');

          case 35:
            _context.t1 = newVersion || calcNextVersion(masterVersion, incrementVersionBy);

            if (_context.t1) {
              _context.next = 40;
              break;
            }

            _context.next = 39;
            return promptNextVersion(masterVersion);

          case 39:
            _context.t1 = _context.sent;

          case 40:
            nextVersion = _context.t1;

            if (!confirm) {
              _context.next = 48;
              break;
            }

            _context.next = 44;
            return _inquirer2.default.prompt([{
              name: 'confirmPublish',
              type: 'confirm',
              message: 'Confirm release (' + _storyboard.chalk.yellow.bold(dirty.length) + ' package/s, ' + ('v' + _storyboard.chalk.cyan.bold(nextVersion) + ')?'),
              default: false
            }]);

          case 44:
            _ref4 = _context.sent;
            confirmPublish = _ref4.confirmPublish;

            if (confirmPublish) {
              _context.next = 48;
              break;
            }

            return _context.abrupt('return');

          case 48:

            // Update package.json's for dirty packages AND THE ROOT PACKAGE + changelog
            dirtyPlusRoot = dirty.concat(_readSpecs.ROOT_PACKAGE);

            for (i = 0; i < dirtyPlusRoot.length; i++) {
              pkgName = dirtyPlusRoot[i];
              _allSpecs$pkgName = allSpecs[pkgName], specPath = _allSpecs$pkgName.specPath, specs = _allSpecs$pkgName.specs;

              specs.version = nextVersion;
              (0, _writeSpecs2.default)(specPath, specs);
            }
            if (changelog) (0, _changelog.addVersionLine)({ changelogPath: changelogPath, version: nextVersion, _date: _date });

            // Commit, tag and push

            if (!gitCommit) {
              _context.next = 58;
              break;
            }

            _context.next = 54;
            return (0, _git.gitCommitChanges)('v' + nextVersion);

          case 54:
            _context.next = 56;
            return (0, _git.gitAddTag)('v' + nextVersion);

          case 56:
            _context.next = 58;
            return (0, _git.gitPushWithTags)();

          case 58:
            if (!npmPublish) {
              _context.next = 72;
              break;
            }

            _i = 0;

          case 60:
            if (!(_i < dirty.length)) {
              _context.next = 72;
              break;
            }

            _pkgName = dirty[_i];
            _allSpecs$_pkgName = allSpecs[_pkgName], pkgPath = _allSpecs$_pkgName.pkgPath, specs = _allSpecs$_pkgName.specs;

            if (!specs.private) {
              _context.next = 65;
              break;
            }

            return _context.abrupt('continue', 69);

          case 65:
            // we don't want npm to complain :)
            cmd = 'npm publish';

            if (publishTag != null) cmd += ' --tag ' + publishTag;
            _context.next = 69;
            return (0, _shell.exec)(cmd, { cwd: pkgPath });

          case 69:
            _i++;
            _context.next = 60;
            break;

          case 72:
          case 'end':
            return _context.stop();
        }
      }
    }, _callee, undefined);
  }));

  return function run(_x) {
    return _ref.apply(this, arguments);
  };
}();

// ------------------------------------------------
// Helpers
// ------------------------------------------------
var prepublishChecks = function () {
  var _ref5 = _asyncToGenerator(regeneratorRuntime.mark(function _callee2(_ref6) {
    var master = _ref6.master,
        checkUncommitted = _ref6.checkUncommitted,
        checkUnpulled = _ref6.checkUnpulled;
    var branch, uncommitted, unpulled;
    return regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            if (DEBUG_SKIP_CHECKS) {
              _storyboard.mainStory.warn('DEBUG_SKIP_CHECKS should be disabled!!');
            }

            // Check current branch
            _context2.next = 3;
            return (0, _git.gitCurBranch)();

          case 3:
            branch = _context2.sent;

            if (!(branch !== 'master')) {
              _context2.next = 12;
              break;
            }

            if (!master) {
              _context2.next = 9;
              break;
            }

            _storyboard.mainStory.error('Can\'t publish from current branch: ' + _storyboard.chalk.bold(branch));

            if (DEBUG_SKIP_CHECKS) {
              _context2.next = 9;
              break;
            }

            throw new Error('BRANCH_CHECK_FAILED');

          case 9:
            _storyboard.mainStory.warn('Publishing from a non-master branch: ' + _storyboard.chalk.red.bold(branch));
            _context2.next = 13;
            break;

          case 12:
            _storyboard.mainStory.info('Current branch: ' + _storyboard.chalk.yellow.bold(branch));

          case 13:
            _context2.next = 15;
            return (0, _git.gitUncommittedChanges)();

          case 15:
            uncommitted = _context2.sent;

            if (!(uncommitted !== '')) {
              _context2.next = 24;
              break;
            }

            if (!checkUncommitted) {
              _context2.next = 21;
              break;
            }

            _storyboard.mainStory.error('Can\'t publish with uncommitted changes (stash/commit them): \n' + _storyboard.chalk.bold(uncommitted));

            if (DEBUG_SKIP_CHECKS) {
              _context2.next = 21;
              break;
            }

            throw new Error('UNCOMMITTED_CHECK_FAILED');

          case 21:
            _storyboard.mainStory.warn('Publishing with uncommitted changes');
            _context2.next = 25;
            break;

          case 24:
            _storyboard.mainStory.info('No uncommitted changes');

          case 25:
            _context2.next = 27;
            return (0, _git.gitUnpulledChanges)();

          case 27:
            unpulled = _context2.sent;

            if (!(unpulled !== '0')) {
              _context2.next = 36;
              break;
            }

            if (!checkUnpulled) {
              _context2.next = 33;
              break;
            }

            _storyboard.mainStory.error('Remote history differs. Please pull changes');

            if (DEBUG_SKIP_CHECKS) {
              _context2.next = 33;
              break;
            }

            throw new Error('UNPULLED_CHECK_FAILED');

          case 33:
            _storyboard.mainStory.warn('Publishing with unpulled changes');
            _context2.next = 37;
            break;

          case 36:
            _storyboard.mainStory.info('Remote history matches local history');

          case 37:
          case 'end':
            return _context2.stop();
        }
      }
    }, _callee2, undefined);
  }));

  return function prepublishChecks(_x2) {
    return _ref5.apply(this, arguments);
  };
}();

var findPackagesToUpdate = function () {
  var _ref7 = _asyncToGenerator(regeneratorRuntime.mark(function _callee3(allSpecs, lastTag) {
    var pkgNames, dirty, i, pkgName, _allSpecs$pkgName2, pkgPath, specs, diff, numChanges;

    return regeneratorRuntime.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            pkgNames = Object.keys(allSpecs);
            dirty = [];
            i = 0;

          case 3:
            if (!(i < pkgNames.length)) {
              _context3.next = 15;
              break;
            }

            pkgName = pkgNames[i];

            if (!(pkgName === _readSpecs.ROOT_PACKAGE)) {
              _context3.next = 7;
              break;
            }

            return _context3.abrupt('continue', 12);

          case 7:
            _allSpecs$pkgName2 = allSpecs[pkgName], pkgPath = _allSpecs$pkgName2.pkgPath, specs = _allSpecs$pkgName2.specs;
            _context3.next = 10;
            return (0, _git.gitDiffSinceIn)(lastTag, pkgPath);

          case 10:
            diff = _context3.sent;

            if (diff !== '') {
              numChanges = diff.split('\n').length;

              _storyboard.mainStory.info('- Package ' + pkgName + ' (currently ' + _storyboard.chalk.cyan.bold(specs.version) + ') has changed (#files: ' + numChanges + ')');
              dirty.push(pkgName);
            }

          case 12:
            i++;
            _context3.next = 3;
            break;

          case 15:
            return _context3.abrupt('return', dirty);

          case 16:
          case 'end':
            return _context3.stop();
        }
      }
    }, _callee3, undefined);
  }));

  return function findPackagesToUpdate(_x3, _x4) {
    return _ref7.apply(this, arguments);
  };
}();

var getMasterVersion = function () {
  var _ref8 = _asyncToGenerator(regeneratorRuntime.mark(function _callee4(allSpecs, lastTag) {
    var masterVersion, tagVersion, _ref9, _confirm;

    return regeneratorRuntime.wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            masterVersion = allSpecs[_readSpecs.ROOT_PACKAGE].specs.version;

            if (!(lastTag != null)) {
              _context4.next = 17;
              break;
            }

            tagVersion = _semver2.default.clean(lastTag);

            _storyboard.mainStory.info('Last tag found: ' + _storyboard.chalk.yellow.bold(lastTag));

            if (!(tagVersion !== masterVersion)) {
              _context4.next = 15;
              break;
            }

            _storyboard.mainStory.warn('Last tagged version ' + _storyboard.chalk.cyan.bold(tagVersion) + ' does not match package.json version ' + _storyboard.chalk.cyan.bold(masterVersion));
            _storyboard.mainStory.warn('This may cause inaccuracies when determining which packages ' + 'need to be released, since oao uses tags to detect package changes');
            _context4.next = 9;
            return _inquirer2.default.prompt([{
              name: 'confirm',
              type: 'confirm',
              message: 'Continue?',
              default: false
            }]);

          case 9:
            _ref9 = _context4.sent;
            _confirm = _ref9.confirm;

            if (_confirm) {
              _context4.next = 13;
              break;
            }

            return _context4.abrupt('return', null);

          case 13:
            if (_semver2.default.valid(tagVersion) && _semver2.default.gt(tagVersion, masterVersion)) {
              masterVersion = tagVersion;
            }
            _storyboard.mainStory.warn('Using ' + _storyboard.chalk.cyan.bold(masterVersion) + ' as reference (the highest one of both)');

          case 15:
            _context4.next = 18;
            break;

          case 17:
            _storyboard.mainStory.warn('Repo has no tags yet');

          case 18:
            if (_semver2.default.valid(masterVersion)) {
              _context4.next = 21;
              break;
            }

            _storyboard.mainStory.error('Master version ' + _storyboard.chalk.cyan.bold(masterVersion) + ' is invalid. Please correct it manually');
            throw new Error('INVALID_VERSION');

          case 21:
            return _context4.abrupt('return', masterVersion);

          case 22:
          case 'end':
            return _context4.stop();
        }
      }
    }, _callee4, undefined);
  }));

  return function getMasterVersion(_x5, _x6) {
    return _ref8.apply(this, arguments);
  };
}();

var calcNextVersion = function calcNextVersion(prevVersion) {
  var incrementBy = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';

  var isPreRelease = PRERELEASE_INCREMENTS.indexOf(incrementBy) >= 0;
  var increment = isPreRelease ? 'prerelease' : incrementBy;
  var isNewPreRelease = isPreRelease && prevVersion.indexOf(incrementBy) < 0;
  return isNewPreRelease ? _semver2.default.inc(prevVersion, 'major') + '-' + incrementBy + '.0' : _semver2.default.inc(prevVersion, increment);
};

var promptNextVersion = function () {
  var _ref10 = _asyncToGenerator(regeneratorRuntime.mark(function _callee5(prevVersion) {
    var major, minor, patch, prerelease, rc, beta, alpha, _ref11, nextVersion;

    return regeneratorRuntime.wrap(function _callee5$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            major = _semver2.default.inc(prevVersion, 'major');
            minor = _semver2.default.inc(prevVersion, 'minor');
            patch = _semver2.default.inc(prevVersion, 'patch');
            prerelease = _semver2.default.inc(prevVersion, 'prerelease');
            rc = prevVersion.indexOf('rc') < 0 ? major + '-rc.0' : prerelease;
            beta = prevVersion.indexOf('beta') < 0 ? major + '-beta.0' : prerelease;
            alpha = prevVersion.indexOf('alpha') < 0 ? major + '-alpha.0' : prerelease;
            _context5.next = 9;
            return _inquirer2.default.prompt([{
              name: 'nextVersion',
              type: 'list',
              message: 'Current version is ' + _storyboard.chalk.cyan.bold(prevVersion) + '. Next one?',
              choices: [{ name: 'Major (' + _storyboard.chalk.cyan.bold(major) + ')', value: major }, { name: 'Minor (' + _storyboard.chalk.cyan.bold(minor) + ')', value: minor }, { name: 'Patch (' + _storyboard.chalk.cyan.bold(patch) + ')', value: patch }, { name: 'Release candidate (' + _storyboard.chalk.cyan.bold(rc) + ')', value: rc }, { name: 'Beta (' + _storyboard.chalk.cyan.bold(beta) + ')', value: beta }, { name: 'Alpha (' + _storyboard.chalk.cyan.bold(alpha) + ')', value: alpha }],
              defaultValue: 2
            }]);

          case 9:
            _ref11 = _context5.sent;
            nextVersion = _ref11.nextVersion;
            return _context5.abrupt('return', nextVersion);

          case 12:
          case 'end':
            return _context5.stop();
        }
      }
    }, _callee5, undefined);
  }));

  return function promptNextVersion(_x8) {
    return _ref10.apply(this, arguments);
  };
}();

// ------------------------------------------------
// Public
// ------------------------------------------------
exports.default = run;