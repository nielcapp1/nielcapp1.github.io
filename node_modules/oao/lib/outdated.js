'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _storyboard = require('storyboard');

var _semver = require('semver');

var _semver2 = _interopRequireDefault(_semver);

var _readSpecs = require('./utils/readSpecs');

var _removeInternalLinks = require('./utils/removeInternalLinks');

var _removeInternalLinks2 = _interopRequireDefault(_removeInternalLinks);

var _writeSpecs = require('./utils/writeSpecs');

var _writeSpecs2 = _interopRequireDefault(_writeSpecs);

var _shell = require('./utils/shell');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

var run = function () {
  var _ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee(opts) {
    var src, ignoreSrc, linkPattern, allSpecs, pkgNames, _loop, i;

    return regeneratorRuntime.wrap(function _callee$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            src = opts.src, ignoreSrc = opts.ignoreSrc, linkPattern = opts.link;
            _context2.next = 3;
            return (0, _readSpecs.readAllSpecs)(src, ignoreSrc);

          case 3:
            allSpecs = _context2.sent;
            pkgNames = Object.keys(allSpecs);
            _loop = regeneratorRuntime.mark(function _loop(i) {
              var pkgName, _allSpecs$pkgName, pkgPath, specPath, prevSpecs, story, fModified, allRemovedPackages, tmp, nextSpecs;

              return regeneratorRuntime.wrap(function _loop$(_context) {
                while (1) {
                  switch (_context.prev = _context.next) {
                    case 0:
                      pkgName = pkgNames[i];
                      _allSpecs$pkgName = allSpecs[pkgName], pkgPath = _allSpecs$pkgName.pkgPath, specPath = _allSpecs$pkgName.specPath, prevSpecs = _allSpecs$pkgName.specs;
                      story = _storyboard.mainStory.child({
                        title: 'Outdated dependencies in ' + _storyboard.chalk.cyan.bold(pkgName),
                        level: 'info'
                      });

                      // Rewrite package.json without own/linked packages, run `yarn outdated`, and revert changes

                      fModified = false;
                      allRemovedPackages = void 0;
                      _context.prev = 5;
                      tmp = (0, _removeInternalLinks2.default)(prevSpecs, pkgNames, linkPattern);
                      nextSpecs = tmp.nextSpecs;

                      allRemovedPackages = tmp.allRemovedPackages;
                      if (nextSpecs !== prevSpecs) {
                        (0, _writeSpecs2.default)(specPath, nextSpecs);
                        fModified = true;
                      }
                      _context.next = 12;
                      return (0, _shell.exec)('yarn outdated', {
                        cwd: pkgPath,
                        story: story,
                        createChildStory: false,
                        logLevel: 'trace'
                      });

                    case 12:
                      _context.next = 18;
                      break;

                    case 14:
                      _context.prev = 14;
                      _context.t0 = _context['catch'](5);

                      story.close();
                      throw _context.t0;

                    case 18:
                      _context.prev = 18;

                      if (prevSpecs != null && fModified) (0, _writeSpecs2.default)(specPath, prevSpecs);
                      return _context.finish(18);

                    case 21:

                      // Log warnings when linked sub-packages do not match the specified range
                      try {
                        Object.keys(allRemovedPackages).forEach(function (depName) {
                          var depVersionRange = allRemovedPackages[depName];
                          var depSpecs = allSpecs[depName];
                          if (!depSpecs) return; // might not exist, if it's a custom link
                          var depActualVersion = depSpecs.specs.version;
                          if (!_semver2.default.satisfies(depActualVersion, depVersionRange)) {
                            story.warn('| - Warning: ' + _storyboard.chalk.cyan.bold(depName + '@' + depActualVersion) + ' ' + ('does not satisfy the specified range: ' + _storyboard.chalk.cyan.bold(depVersionRange)));
                          }
                        });
                      } finally {
                        story.close();
                      }

                    case 22:
                    case 'end':
                      return _context.stop();
                  }
                }
              }, _loop, undefined, [[5, 14, 18, 21]]);
            });
            i = 0;

          case 7:
            if (!(i < pkgNames.length)) {
              _context2.next = 12;
              break;
            }

            return _context2.delegateYield(_loop(i), 't0', 9);

          case 9:
            i++;
            _context2.next = 7;
            break;

          case 12:
          case 'end':
            return _context2.stop();
        }
      }
    }, _callee, undefined);
  }));

  return function run(_x) {
    return _ref.apply(this, arguments);
  };
}();

exports.default = run;